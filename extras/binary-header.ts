import {
  Command,
  EnumType,
} from "https://deno.land/x/cliffy@v1.0.0-rc.3/command/mod.ts";
import { basename } from "https://deno.land/std@0.203.0/path/posix.ts";

const LINE_LENGTH = 80;

const stringType = new EnumType(["string_view", "string", "char"]);

await new Command()
  .name("binary-header")
  .description(
    "Generate a C++ header with a single string literal, from a binary file",
  )
  .helpOption("--help", "Show this help.")
  .option(
    "-o, --out <filename:string>",
    "Output file. If not present, outputs to stdout.",
  )
  .option(
    "-i, --identifier <symbol:string>",
    "The name of the variable to define. If not present, generated by slugifying the filename.",
  )
  .type("stringType", stringType)
  .option(
    "-t, --type <typename:stringType>",
    'The type of the variable to define. Can be "string", "string_view", or "char".',
    { default: "string_view" },
  )
  .option("--once", `Add a "#pragma once" directive`)
  .arguments("<filename:string>")
  .action(async ({ out, identifier, type, once }, filename) => {
    const varName = identifier || basename(filename).replace(/[^\w]/g, "_");
    if (!/[a-z][\w*]/i.test(varName)) {
      throw new Error(
        `Identifier ${JSON.stringify(identifier)} is not a legal C identifier`,
      );
    }
    const src = await Deno.readFile(filename),
      outFile = out ? await Deno.create(out) : Deno.stdout,
      enc = new TextEncoder(),
      write = (s: string) => outFile.write(enc.encode(s));
    try {
      await write(
        "// Automatically generated by binary-header.ts\n",
      );
      if (once) await write("#pragma once\n");
      switch (type) {
        case "string_view":
          await write(
            `#include <string_view>\nstatic constexpr std::string_view ${varName} =`,
          );
          break;
        case "string":
          await write(
            `#include <string>\nstatic constexpr std::string ${varName} =`,
          );
          break;
        case "char":
          await write(`static constexpr char ${varName}[] =`);
          break;
      }
      let i = 0;
      for (let line = 0; line < Math.ceil(src.length / LINE_LENGTH); line++) {
        let str = '\n  "';
        for (let ii = 0; ii < LINE_LENGTH && i < src.length; i++, ii++) {
          const c = src[i];
          if (
            c >= 32 && c <= 126 && c != '"'.charCodeAt(0) &&
            c != "\\".charCodeAt(0) && c != "?".charCodeAt(0) &&
            c != ":".charCodeAt(0) && c != "%".charCodeAt(0)
          ) {
            str += String.fromCharCode(c);
          } else if (c == "\r".charCodeAt(0)) {
            str += "\\r";
          } else if (c == "\n".charCodeAt(0)) {
            str += "\\n";
          } else if (c == "\t".charCodeAt(0)) {
            str += "\\t";
          } else if (c == '"'.charCodeAt(0)) {
            str += '\\"';
          } else if (c == "\\".charCodeAt(0)) {
            str += "\\\\";
          } else {
            str += `\\${c.toString(8).padStart(3, "0")}`;
          }
        }
        str += '"';
        await write(str);
      }
      await write(";\n");
    } finally {
      if (out) outFile.close();
    }
  })
  .parse(Deno.args);
